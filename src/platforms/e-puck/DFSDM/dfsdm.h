/** @file dfsdm.h
 * DFSDM microphone driver
 *
 * This module implements a simple 2-channels DFSDM microphone driver.
 *
 * The driver operates using DMA in circular mode, which means that while one
 * buffer is processed by the user's code, the other half is used by the DMA to
 * store the samples. This allows real time processing of the samples without
 * data loss. It is similar to what is done for the ADCs drivers by ChibiOS.
 * It is only used when contiuous mode is selected for the conversion, otherwise the
 * DMA stops when the buffer is full
 *
 * This driver has been adapted from the one made for the DiscoveryF7
 * board
 */
#ifndef DFSDM_H
#define DFSDM_H

#include "register_complement.h"

#define AUDIO_BUFFER_SIZE   44100

#define DFSDM_RISING_EDGE 0
#define DFSDM_FALLING_EDGE 1

#define DFSDM_SELF  0
#define DFSDM_NEXT  1

#define DFSDM_ONESHOT       false
#define DFSDM_CONTINUOUS    true

/*DMA*/
#define STM32_DFSDM_MICROPHONE_DMA_PRIORITY DMA_SxCR_PL_HIGH
#define STM32_DFSDM_MICROPHONE_DMA_IRQ_PRIORITY 6

/*indicates if datas are ready to be read
* should be clear by user after use
* set by interruption at half the buffer if contiuous mode is selected
* or at the end of the buffer otherwise
* 
**/
volatile bool dfsdm_data_ready;
/*
* samples points at the beginning of the last buffer filled by the DMA
* or at the half of it depending on the interruption generated by the DMA when
* continuous mode is selected.
* 
* If not it always points to the beginning of the buffer.
* 
**/
int32_t *samples;

/** Callback type for data received
 *
 * @param [in] drv Pointer provided by the user in the DFSDM config.
 * @param [in] buffer A pointer to the buffer holding the samples.
 * @param [in] n number of samples in the buffer.
 */
typedef void (*dfsdmcallback_t)(void *drv, int32_t *buffer, size_t n);

/** Callback type for DMA errors.
 *
 * @param [in] drv Pointer provided by the user in the DFSDM config.
 */
typedef void (*dfsdmerrorcallback_t)(void *drv);

/** Configuration for one of the two DFSDM microophone channels. */
typedef struct {
    /** Callback called when samples_len/2 samples have been read. */
    dfsdmcallback_t end_cb;

    /** Callback in case of DMA error. */
    dfsdmerrorcallback_t error_cb;

    /** Argument passed to the callbacks. */
    void *cb_arg;

    /** Pointer to a buffer to hold the samples. Filled by interrupt */
    int32_t *samples;

    /** Length of the samples buffer, in number of elements. */
    size_t samples_len;

    /** DMA controller to use : DMAx see group STM32F4xx_dma_defines */
    uint32_t dma;

    /** DMA stream to use : DMA_STREAMx see group STM32F4xx_dma_defines */
    uint32_t dma_stream;

    /** DMA channel to use : DMA_SxCR_CHSEL_x see group dma_ch_sel */
    uint32_t dma_channel;

    /** DMA priority to set : Defined on top of the file */
    uint32_t dma_priority;

    /** DFSDM channel to use : DFSDMx_Channelx  see DFSDM_Channel_TypeDef */
    DFSDM_Channel_TypeDef* dfsdm_channel;

    /** Define to which input the dfsdm channel should be connected. DFSDM_SELF of DFSDM_NEXT */
    uint8_t dfsdm_input;

    /** Define which edge the channel should read. DFSDM_RISING_EDGE or DFSDM_FALLING_EGDE  */
    uint8_t dfsdm_edge;

    /** Filter to use :  DFSDMx_Filterx see DFSDM_Filter_TypeDef */
    DFSDM_Filter_TypeDef* dfsdm_filter;

} DFSDM_config_t;

/** Configure the hardware peripherals. */
void dfsdm_start(void);

/** Starts the acquisition. */
void dfsdm_start_conversion(DFSDM_config_t *mic_config, bool continuous);

/** Stops the continous acquisition. */
void dfsdm_stop_conversion(void);

void dfsdm_data_callback(void *p, int32_t *buffer, size_t n);

void dfsdm_err_cb(void *p);

#endif
